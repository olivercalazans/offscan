use std::collections::HashMap;



pub struct UdpPayloads {
    payloads: HashMap<u16, Vec<u8>>,
}



impl UdpPayloads {

    pub fn new() -> Self {
        let mut payloads = HashMap::new();


        payloads.insert(0, // Empty payload
            vec![]
        );
        

        payloads.insert(53, // DNS Query for google.com
            vec![
                0xaa, 0xaa, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x06, b'g', b'o', b'o', b'g', b'l', b'e', 0x03, 
                b'c', b'o', b'm', 0x00, 0x00, 0x01, 0x00, 0x01
            ]
        );


        payloads.insert(67, // DHCP Discover
            vec![
                // DHCP Header
                0x01, 0x01, 0x06, 0x00, // OP: Boot Request (1), HTYPE: Ethernet (1), HLEN: Ethernet = 6, HOPS: 0
                0x39, 0x03, 0xF3, 0x26, // XID: Transaction ID (random) 
                0x00, 0x00, 0x00, 0x00, // SECS: 0, FLAGS: 0
                0x00, 0x00, 0x00, 0x00, // CIADDR: Client IP Address (0.0.0.0)
                0x00, 0x00, 0x00, 0x00, // YIADDR: Your IP Address (0.0.0.0)
                0x00, 0x00, 0x00, 0x00, // SIADDR: Server IP Address (0.0.0.0)
                0x00, 0x00, 0x00, 0x00, // GIADDR: Relay Agent IP Address (0.0.0.0)
                 
                // CHADDR: Client MAC
                0x36, 0x2C, 0x91, 0x17, 0xCD, 0xFE, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                 
                // SNAME: Server Name (64 zeros)
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                 
                // FILE: Boot File Name (128 zeros)
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                 
                // DHCP Options
                0x63, 0x82, 0x53, 0x63,                               // Magic Cookie
                0x35, 0x01, 0x01,                                     // DHCP Message Type: Discover
                0x3D, 0x07, 0x01, 0x36, 0x2C, 0x91, 0x17, 0xCD, 0xFE, // Client Identifier
                0x37, 0x04, 0x01, 0x03, 0x06, 0x2A,                   // Parameter Request List
                0xFF                                                  // End Option
            ]
        );
        

        payloads.insert(69, // TFTP Read Request for test.txt
            {
                let mut data = vec![0x00, 0x01]; // OPCODE = Read
                data.extend_from_slice(b"test.txt");
                data.push(0x00);
                data.extend_from_slice(b"octet");
                data.push(0x00);
                data
            }
        );
        
 
        payloads.insert(123, // NTP Client Request
            vec![
                0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            ]
        );
        

        payloads.insert(137, // NetBIOS Name Query
            vec![
                0x82, 0x84, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x20, b'C', b'K', 0x41, 0x41, 0x41, 0x41, 0x41, 
                0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
                0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
                0x41, 0x41, 0x41, 0x41, 0x41, 0x00, 0x00, 0x21, 0x00, 0x01
            ]
        );


        payloads.insert(161, // SNMP GetRequest with community 'public'
            vec![
                0x30, 0x26, 0x02, 0x01, 0x01, 0x04, 0x06, b'p', b'u', b'b', 
                b'l', b'i', b'c', 0xa0, 0x19, 0x02, 0x04, 0x71, 0xb4, 0xb5, 
                0x68, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00, 0x30, 0x0b, 0x30, 
                0x09, 0x06, 0x05, 0x2b, 0x06, 0x01, 0x02, 0x01, 0x05, 0x00
            ]
        );
        

        payloads.insert(162, // SNMP Trap
            vec![
                0x30, 0x33, 0x02, 0x01, 0x01, 0x04, 0x06, b'p', b'u', b'b', 
                b'l', b'i', b'c', 0xa7, 0x26, 0x02, 0x04, 0x00, 0x00, 0x00, 
                0x01, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00, 0x30, 0x1a, 0x30, 
                0x0e, 0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01, 0xbf, 0x08, 
                0x03, 0x02, 0x0a, 0x40, 0x04, 0x00, 0x30, 0x08, 0x06, 0x04, 
                0x2b, 0x06, 0x01, 0x02, 0x05, 0x00
            ]
        );


        UdpPayloads { payloads }
    }
    


    pub fn get_payload_or_empty(&self, port: u16) -> &Vec<u8> {
        self.payloads.get(&port).unwrap_or_else(|| {
            self.payloads.get(&0).expect("Empty payload should exist")
        })
    }



    pub fn len(&self) -> usize {
        self.payloads.len() - 1
    }



    pub fn get(&self, port: u16) -> Option<&Vec<u8>> {
        self.payloads.get(&port)
    }



    pub fn iter(&self) -> impl Iterator<Item = (u16, &Vec<u8>)> + '_ {
        self.payloads.iter()
            .filter(|&(&port, _)| port != 0)
            .map(|(&port, payload)| (port, payload))
    }

}
use std::{collections::HashMap, net::Ipv4Addr};



pub struct UdpPayloads {
    payloads: HashMap<u16, Vec<u8>>,
}



impl UdpPayloads {

    pub fn new(my_ip: Ipv4Addr) -> Self {
        let mut payloads = HashMap::new();
        let ip_bytes     = my_ip.octets();


        payloads.insert(0, // Empty payload
            vec![]
        );
        

        payloads.insert(53, // DNS Query for google.com
            vec![
                0xaa, 0xaa, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x06, b'g', b'o', b'o', b'g', b'l', b'e', 0x03, 
                b'c', b'o', b'm', 0x00, 0x00, 0x01, 0x00, 0x01
            ]
        );


        payloads.insert(67, // DHCPINFORM
            vec![
                // DHCP Header
                0x01, 0x01, 0x06, 0x00, // op, htype, hlen, hops
                0x39, 0x03, 0xF3, 0x26, // xid
                0x00, 0x00, 0x00, 0x00, // secs, flags
                // ciaddr (seu IP)
                ip_bytes[0], ip_bytes[1], ip_bytes[2], ip_bytes[3],
                // yiaddr, siaddr, giaddr
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                // chaddr
                0x08, 0x00, 0x27, 0x00, 0x00, 0x01, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                // sname (64 zeros)
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00,
                // file (128 zeros)
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                // Magic cookie + Options
                0x63, 0x82, 0x53, 0x63, // magic cookie
                0x35, 0x01, 0x08, // dhcp message type (inform)
                0x3d, 0x07, 0x01, 0x08, 0x00, 0x27, 0x00, 0x00, 0x01, // client identifier
                0x37, 0x04, 0x01, 0x03, 0x06, 0x2a, // parameter request list
                0x0c, 0x08, 0x6d, 0x79, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, // hostname
                0xff, // end option
                // padding para 300 bytes
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            ]
        );
        

        payloads.insert(69, // TFTP Read Request for test.txt
            {
                let mut data = vec![0x00, 0x01]; // OPCODE = Read
                data.extend_from_slice(b"test.txt");
                data.push(0x00);
                data.extend_from_slice(b"octet");
                data.push(0x00);
                data
            }
        );
        
 
        payloads.insert(123, // NTP Client Request
            vec![
                0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            ]
        );
        

        payloads.insert(137, // NetBIOS Name Query
            vec![
                0x82, 0x84, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x20, b'C', b'K', 0x41, 0x41, 0x41, 0x41, 0x41, 
                0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
                0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
                0x41, 0x41, 0x41, 0x41, 0x41, 0x00, 0x00, 0x21, 0x00, 0x01
            ]
        );


        payloads.insert(161, // SNMP GetRequest with community 'public'
            vec![
                0x30, 0x26, 0x02, 0x01, 0x01, 0x04, 0x06, b'p', b'u', b'b', 
                b'l', b'i', b'c', 0xa0, 0x19, 0x02, 0x04, 0x71, 0xb4, 0xb5, 
                0x68, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00, 0x30, 0x0b, 0x30, 
                0x09, 0x06, 0x05, 0x2b, 0x06, 0x01, 0x02, 0x01, 0x05, 0x00
            ]
        );
        

        payloads.insert(162, // SNMP Trap
            vec![
                0x30, 0x33, 0x02, 0x01, 0x01, 0x04, 0x06, b'p', b'u', b'b', 
                b'l', b'i', b'c', 0xa7, 0x26, 0x02, 0x04, 0x00, 0x00, 0x00, 
                0x01, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00, 0x30, 0x1a, 0x30, 
                0x0e, 0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01, 0xbf, 0x08, 
                0x03, 0x02, 0x0a, 0x40, 0x04, 0x00, 0x30, 0x08, 0x06, 0x04, 
                0x2b, 0x06, 0x01, 0x02, 0x05, 0x00
            ]
        );


        UdpPayloads { payloads }
    }
    


    pub fn get_payload_or_empty(&self, port: u16) -> &Vec<u8> {
        self.payloads.get(&port).unwrap_or_else(|| {
            self.payloads.get(&0).expect("Empty payload should exist")
        })
    }



    pub fn len(&self) -> usize {
        self.payloads.len() - 1
    }



    pub fn get(&self, port: u16) -> Option<&Vec<u8>> {
        self.payloads.get(&port)
    }



    pub fn iter(&self) -> impl Iterator<Item = (u16, &Vec<u8>)> + '_ {
        self.payloads.iter()
            .filter(|&(&port, _)| port != 0)
            .map(|(&port, payload)| (port, payload))
    }

}
use std::{collections::HashMap, net::Ipv4Addr};



pub struct UdpPayloads {
    payloads: HashMap<u16, Vec<u8>>,
}



impl UdpPayloads {

    pub fn new(my_ip: Ipv4Addr) -> Self {
        let mut payloads = HashMap::new();
        let ip_bytes     = my_ip.octets();


        payloads.insert(0, // Empty payload
            vec![]
        );
        

        payloads.insert(53, // DNS Query for google.com
            vec![
                0xaa, 0xaa, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x06, b'g', b'o', b'o', b'g', b'l', b'e', 0x03, 
                b'c', b'o', b'm', 0x00, 0x00, 0x01, 0x00, 0x01
            ]
        );


        payloads.insert(67, // DHCPINFORM
            vec![
                // DHCP Header
                0x01, 0x01, 0x06, 0x00,
                0x39, 0x03, 0xF3, 0x26,
                0x00, 0x00, 0x00, 0x00,
                ip_bytes[0], ip_bytes[1], ip_bytes[2], ip_bytes[3],
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x08, 0x00, 0x27, 0x00, 0x00, 0x01, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x63, 0x82, 0x53, 0x63,
                0x35, 0x01, 0x08, // dhcp message type (inform)
                0x3d, 0x07, 0x01, 0x08, 0x00, 0x27, 0x00, 0x00, 0x01,
                0x37, 0x04, 0x01, 0x03, 0x06, 0x2a, 
                0x0c, 0x08, 0x6d, 0x79, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74,
                0xff, // end option
                // padding para 300 bytes
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            ]
        );
        

        payloads.insert(69, // TFTP Read Request for test.txt
            {
                let mut data = vec![0x00, 0x01]; // OPCODE = Read
                data.extend_from_slice(b"test.txt");
                data.push(0x00);
                data.extend_from_slice(b"octet");
                data.push(0x00);
                data
            }
        );


        payloads.insert(111, // RPCCheck
            vec![
                0x72, 0xFE, 0x1D, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x02, 0x00, 0x01, 0x86, 0xA0, 0x00, 0x01, 0x97, 0x7C,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            ]
        );
        
 
        payloads.insert(123, // NTP Client Request
            vec![
                0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            ]
        );


        payloads.insert(135, // DCERPC Windows RPC Service Detection (Windows RPC Endpoint Mapper)
            vec![
                0x05, 0x00,
                0x0b,                   
                0x03,                   
                0x10, 0x00, 0x00, 0x00, 
                0x48, 0x00,             
                0x00, 0x00,              
                0x01, 0x00, 0x00, 0x00,
                0xb8, 0x10, 0xb8, 0x10, 
                0x00, 0x00, 0x00, 0x00, 
                0x01, 0x00,             
                0x00, 0x00,
                0x00, 0x00, 0x01, 0x00,
                0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 
                0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
                0xe7, 0x03, 0x00, 0x00,
                0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
                0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
                0xe7, 0x03, 0x00, 0x00 
            ]
        );
        

        payloads.insert(137, // NetBIOS Name Query
            vec![
                0x82, 0x84, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x20, b'C', b'K', 0x41, 0x41, 0x41, 0x41, 0x41, 
                0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
                0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
                0x41, 0x41, 0x41, 0x41, 0x41, 0x00, 0x00, 0x21, 0x00, 0x01
            ]
        );


        payloads.insert(389, // LDAP (Lightweight Directory Access Protocol)
            vec![
                0x30, 0x84, 0x00, 0x00, 0x00, 0x2d,
                0x02, 0x01, 0x07,
                0x63,
                0x84, 0x00, 0x00, 0x00, 0x24,
                0x04, 0x00,
                0x0a, 0x01, 0x00,
                0x0a, 0x01, 0x00,
                0x02, 0x01, 0x00,
                0x02, 0x01, 0x64,
                0x01, 0x01, 0x00,
                0x87, 0x0b,      
                0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x30,
                0x84, 0x00, 0x00, 0x00, 0x00
            ]
        );


        payloads.insert(161, // SNMP GetRequest with community 'public'
            vec![
                0x30, 0x26, 0x02, 0x01, 0x01, 0x04, 0x06, b'p', b'u', b'b', 
                b'l', b'i', b'c', 0xa0, 0x19, 0x02, 0x04, 0x71, 0xb4, 0xb5, 
                0x68, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00, 0x30, 0x0b, 0x30, 
                0x09, 0x06, 0x05, 0x2b, 0x06, 0x01, 0x02, 0x01, 0x05, 0x00
            ]
        );


        payloads.insert(427, // Standard SLP service port
            vec![
                0x02, // Version: 2 (SLPv2)
                0x01, 
                0x00, 0x00,
                0x36, 0x20, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x01,
                0x00, 0x02,
                0x65, 0x6e,
                0x00, 0x00,
                0x00, 0x15,
                0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x3a,
                0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2d,
                0x61, 0x67, 0x65, 0x6e, 0x74,
                0x00,
                0x07,
                0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74,
                0x00,
                0x00, 0x00, 0x00, 0x00
            ]
        );
        


        UdpPayloads { payloads }
    }
    


    pub fn get_payload_or_empty(&self, port: u16) -> &Vec<u8> {
        self.payloads.get(&port).unwrap_or_else(|| {
            self.payloads.get(&0).expect("Empty payload should exist")
        })
    }



    pub fn len(&self) -> usize {
        self.payloads.len() - 1
    }



    pub fn get(&self, port: u16) -> Option<&Vec<u8>> {
        self.payloads.get(&port)
    }



    pub fn iter(&self) -> impl Iterator<Item = (u16, &Vec<u8>)> + '_ {
        self.payloads.iter()
            .filter(|&(&port, _)| port != 0)
            .map(|(&port, payload)| (port, payload))
    }

}